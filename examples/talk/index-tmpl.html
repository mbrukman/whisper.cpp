<!doctype html>
<html lang="en-us">
    <head>
        <title>talk : GPT-2 meets Whisper in WebAssembly</title>

        <style>
            #output {
                width: 100%;
                height: 100%;
                margin: 0 auto;
                margin-top: 10px;
                border-left: 0px;
                border-right: 0px;
                padding-left: 0px;
                padding-right: 0px;
                display: block;
                background-color: black;
                color: white;
                font-size: 10px;
                font-family: 'Lucida Console', Monaco, monospace;
                outline: none;
                white-space: pre;
                overflow-wrap: normal;
                overflow-x: scroll;
            }
        </style>
    </head>
    <body>
        <div id="main-container">
            <b>talk : GPT-2 meets Whisper in WebAssembly</b>

            <br><br>

            WIP IN PROGRESS

            <br><br><hr>

            <div id="model-whisper">
                Whisper Model:
                <button id="fetch-whisper-tiny-en" onclick="loadWhisper('tiny.en')">tiny.en (75 MB)</button>
                <button id="fetch-whisper-base-en" onclick="loadWhisper('base.en')">base.en (142 MB)</button>
                <span id="fetch-whisper-progress"></span>

                <!--
                <input type="file" id="file" name="file" onchange="loadFile(event, 'whisper.bin')" />
                -->
            </div>

            <br>

            <div id="model-gpt-2">
                GPT-2 Model:
                <button id="fetch-gpt-2-small" onclick="loadGPT2('small')">small 117M (240 MB)</button>
                <!--<button id="fetch-gpt-2-medium" onclick="loadGPT2('medium')">medium 345M (720 MB)</button>-->
                <span id="fetch-gpt-2-progress"></span>

                <!--
                <input type="file" id="file" name="file" onchange="loadFile(event, 'gpt-2.bin')" />
                -->
            </div>

            <br>

            <div id="input_mic">
                <button id="start" onclick="onStart()">Start</button>
                <button id="stop" onclick="onStop()" disabled>Stop</button>
                <button id="speak" onclick="speakTest()">Speak</button>
                <button id="speak" onclick="clearCache()">Clear Cache</button>
            </div>

            <audio controls="controls" id="audio" loop hidden>
                Your browser does not support the &lt;audio&gt; tag.
                <source id="source" src="" type="audio/wav" />
            </audio>

            <hr><br>

            <br>

            <!-- textarea with height filling the rest of the page -->
            <textarea id="output" rows="20"></textarea>

            <br><br>

            <div class="cell-version">
                <span>
                    |
                    Build time: <span class="nav-link">@GIT_DATE@</span> |
                    Commit hash: <a class="nav-link" href="https://github.com/ggerganov/whisper.cpp/commit/@GIT_SHA1@">@GIT_SHA1@</a> |
                    Commit subject: <span class="nav-link">@GIT_COMMIT_SUBJECT@</span> |
                    <a class="nav-link" href="https://github.com/ggerganov/whisper.cpp/tree/master/examples/talk">Source Code</a> |
                </span>
            </div>
        </div>

        <script type='text/javascript'>
            // TODO: convert audio buffer to WAV
            function setAudio(audio) {
                //if (audio) {
                //    // convert to 16-bit PCM
                //    var blob = new Blob([audio], { type: 'audio/wav' });
                //    var url = URL.createObjectURL(blob);
                //    document.getElementById('source').src = url;
                //    document.getElementById('audio').hidden = false;
                //    document.getElementById('audio').loop = false;
                //    document.getElementById('audio').load();
                //} else {
                //    document.getElementById('audio').hidden = true;
                //}
            }

            function changeInput(input) {
                if (input == 'file') {
                    document.getElementById('input_file').style.display = 'block';
                    document.getElementById('input_mic').style.display = 'none';
                } else {
                    document.getElementById('input_file').style.display = 'none';
                    document.getElementById('input_mic').style.display = 'block';
                }
            }

            var printTextarea = (function() {
                    var element = document.getElementById('output');
                    if (element) element.alue = ''; // clear browser cache
                    return function(text) {
                        if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                        console.log(text);
                        if (element) {
                            element.value += text + "\n";
                            element.scrollTop = element.scrollHeight; // focus on bottom
                        }
                    };
                })();

            var Module = {
                print: printTextarea,
                printErr: printTextarea,
                setStatus: function(text) {
                    printTextarea('js: ' + text);
                },
                monitorRunDependencies: function(left) {
                }
            };

            const kMaxAudio_s = 10;
            const kRestartRecording_s = 15;
            const kSampleRate = 16000;

            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            window.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;

            // web audio context
            var context = null;

            // audio data
            var audio = null;
            var audio0 = null;

            // the talk instance
            var instance = null;

            // speech synthesis
            const synth = window.speechSynthesis;

            // helper function
            function convertTypedArray(src, type) {
                var buffer = new ArrayBuffer(src.byteLength);
                var baseView = new src.constructor(buffer).set(src);
                return new type(buffer);
            }

            //
            // fetch models
            //

            function storeFS(fname, buf) {
                // write to WASM file using FS_createDataFile
                // if the file exists, delete it
                try {
                    Module.FS_unlink(fname);
                } catch (e) {
                    // ignore
                }

                Module.FS_createDataFile("/", fname, buf, true, true);

                printTextarea('js: stored model: ' + fname + ' size: ' + buf.length);
            }

            let dbVersion = 1
            let dbName    = 'talk.ggerganov.com';
            let indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB

            // fetch a remote file from remote URL using the Fetch API
            async function fetchRemote(url, elProgress) {
                printTextarea('js: downloading with fetch()...');

                const response = await fetch(
                    url,
                    {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/octet-stream',
                        },
                    }
                );

                if (!response.ok) {
                    printTextarea('js: failed to fetch ' + url);
                    return;
                }

                const contentLength = response.headers.get('content-length');
                const total = parseInt(contentLength, 10);
                const reader = response.body.getReader();

                var chunks = [];
                var receivedLength = 0;
                var progressLast = -1;

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        break;
                    }

                    chunks.push(value);
                    receivedLength += value.length;

                    if (contentLength) {
                        // update progress bar element with the new percentage
                        var progressCur = Math.round((receivedLength / total) * 10);
                        if (progressCur != progressLast) {
                            elProgress.innerHTML = 10*progressCur + '%';
                            printTextarea('js: fetching ' + 10*progressCur + '% ...');
                            progressLast = progressCur;
                        }
                    }
                }

                var chunksAll = new Uint8Array(receivedLength);
                var position = 0;
                for (var chunk of chunks) {
                    chunksAll.set(chunk, position);
                    position += chunk.length;
                }

                return chunksAll;
            }

            // load remote data
            // - check if the data is already in the IndexedDB
            // - if not, fetch it from the remote URL and store it in the IndexedDB
            // - store it in WASM memory
            function loadRemote(url, dst, elProgress) {
                // query the storage quota and print it
                navigator.storage.estimate().then(function (estimate) {
                    printTextarea('js: storage quota: ' + estimate.quota + ' bytes');
                    printTextarea('js: storage usage: ' + estimate.usage + ' bytes');
                });

                // check if the data is already in the IndexedDB
                var request = indexedDB.open(dbName, dbVersion);

                request.onupgradeneeded = function (event) {
                    var db = event.target.result;
                    if (db.version == 1) {
                        var objectStore = db.createObjectStore('models', { autoIncrement: false });
                        printTextarea('js: created IndexedDB ' + db.name + ' version ' + db.version);
                    } else {
                        // clear the database
                        var objectStore = event.currentTarget.transaction.objectStore('models');
                        objectStore.clear();
                        printTextarea('js: cleared IndexedDB ' + db.name + ' version ' + db.version);
                    }
                };

                request.onsuccess = function (event) {
                    var db = event.target.result;
                    var transaction = db.transaction(['models'], 'readonly');
                    var objectStore = transaction.objectStore('models');
                    var request = objectStore.get(url);

                    request.onsuccess = function (event) {
                        if (request.result) {
                            printTextarea('js: "' + url + '" is already in the IndexedDB');
                            storeFS(dst, request.result);
                        } else {
                            // data is not in the IndexedDB
                            printTextarea('js: "' + url + '" is not in the IndexedDB');

                            fetchRemote(url, elProgress).then(function (data) {
                                if (data) {
                                    // store the data in the IndexedDB
                                    var request = indexedDB.open(dbName, dbVersion);
                                    request.onsuccess = function (event) {
                                        var db = event.target.result;
                                        var transaction = db.transaction(['models'], 'readwrite');
                                        var objectStore = transaction.objectStore('models');
                                        var request = objectStore.put(data, url);

                                        request.onsuccess = function (event) {
                                            printTextarea('js: "' + url + '" stored in the IndexedDB');
                                            storeFS(dst, data);
                                        };

                                        request.onerror = function (event) {
                                            printTextarea('js: failed to store "' + url + '" in the IndexedDB');
                                        };
                                    };
                                }
                            });
                        }
                    };

                    request.onerror = function (event) {
                        printTextarea('js: failed to get data from the IndexedDB');
                    };
                };

                request.onerror = function (event) {
                    printTextarea('js: failed to open IndexedDB');
                };

                request.onblocked = function (event) {
                    printTextarea('js: failed to open IndexedDB: blocked');
                };

                request.onabort = function (event) {
                    printTextarea('js: failed to open IndexedDB: abort');
                };
            }

            function loadWhisper(model) {
                let urls = {
                    'tiny.en': 'https://talk.ggerganov.com/ggml-model-whisper-tiny.en.bin',
                    'base.en': 'https://talk.ggerganov.com/ggml-model-whisper-base.en.bin',
                };

                let url = urls[model];
                let dst = 'whisper.bin';
                let el  = document.getElementById('fetch-whisper-progress');

                loadRemote(url, dst, el);
            }

            function loadGPT2(model) {
                let urls = {
                    'small':  'https://talk.ggerganov.com/ggml-model-gpt-2-117M.bin',
                    'medium': 'https://talk.ggerganov.com/ggml-model-gpt-2-345M.bin',
                };

                let url = urls[model];
                let dst = 'gpt-2.bin';
                let el  = document.getElementById('fetch-gpt-2-progress');

                loadRemote(url, dst, el);
            }

            //
            // microphone
            //

            var mediaRecorder = null;
            var doRecording = false;
            var startTime = 0;

            function stopRecording() {
                doRecording = false;
                audio0 = null;
                audio = null;
            }

            function startRecording() {
                if (!context) {
                    context = new AudioContext({sampleRate: 16000});
                }

                document.getElementById('start').disabled = true;
                document.getElementById('stop').disabled = false;

                doRecording = true;
                startTime = Date.now();

                var chunks = [];
                var stream = null;

                navigator.mediaDevices.getUserMedia({audio: true, video: false})
                    .then(function(s) {
                        stream = s;
                        mediaRecorder = new MediaRecorder(stream);
                        mediaRecorder.ondataavailable = function(e) {
                            chunks.push(e.data);

                            var blob = new Blob(chunks, { 'type' : 'audio/ogg; codecs=opus' });
                            var reader = new FileReader();

                            reader.onload = function(event) {
                                var buf = new Uint8Array(reader.result);

                                context.decodeAudioData(buf.buffer, function(audioBuffer) {
                                    var offlineContext = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
                                    var source = offlineContext.createBufferSource();
                                    source.buffer = audioBuffer;
                                    source.connect(offlineContext.destination);
                                    source.start(0);

                                    offlineContext.startRendering().then(function(renderedBuffer) {
                                        audio = renderedBuffer.getChannelData(0);

                                        //printTextarea('js: audio recorded, size: ' + audio.length + ', old size: ' + (audio0 == null ? 0 : audio0.length));

                                        var audioAll = new Float32Array(audio0 == null ? audio.length : audio0.length + audio.length);
                                        if (audio0 != null) {
                                            audioAll.set(audio0, 0);
                                        }
                                        audioAll.set(audio, audio0 == null ? 0 : audio0.length);

                                        if (instance) {
                                            Module.set_audio(instance, audioAll);
                                        }

                                        setAudio(audio);
                                    });
                                }, function(e) {
                                    printTextarea('js: error decoding audio: ' + e);
                                    audio = null;
                                    setAudio(audio);
                                });
                            }

                            reader.readAsArrayBuffer(blob);
                        };

                        mediaRecorder.onstop = function(e) {
                            if (doRecording) {
                                setTimeout(function() {
                                    startRecording();
                                });
                            }
                        };

                        mediaRecorder.start(250);
                    })
                    .catch(function(err) {
                        printTextarea('js: error getting audio stream: ' + err);
                    });

                var interval = setInterval(function() {
                    if (!doRecording) {
                        clearInterval(interval);
                        mediaRecorder.stop();
                        stream.getTracks().forEach(function(track) {
                            track.stop();
                        });

                        document.getElementById('start').disabled = false;
                        document.getElementById('stop').disabled = true;

                        mediaRecorder = null;
                    }

                    // if audio length is more than kRestartRecording_s seconds, restart recording
                    if (audio != null && audio.length > kSampleRate*kRestartRecording_s) {
                        if (doRecording) {
                            //printTextarea('js: restarting recording');

                            clearInterval(interval);
                            audio0 = audio;
                            audio = null;
                            mediaRecorder.stop();
                            stream.getTracks().forEach(function(track) {
                                track.stop();
                            });
                        }
                    }
                }, 250);
            }

            //
            // speak
            //

            var voice = null;

            function onSpeak(text) {
                var voices = synth.getVoices();
                var msg = new SpeechSynthesisUtterance(text);

                if (voice == null) {
                    //voice = voices[Math.floor(Math.random() * 2)];
                    voice = voices[0];
                }

                msg.voice = voice;
                synth.speak(msg);

                if (doRecording) {
                    printTextarea('js: speaking');
                    stopRecording();
                    var interval = setInterval(function() {
                        if (!synth.speaking) {
                            printTextarea('js: done speaking');
                            clearInterval(interval);
                            startRecording();
                        }
                    }, 100);
                }
            }

            async function clearCache() {
                if (confirm('Are you sure you want to clear the cache?\nAll the models will be downloaded again.')) {
                    const dbs = await window.indexedDB.databases();
                    dbs.forEach(db => { window.indexedDB.deleteDatabase(db.name) });
                }
            }

            //
            // main
            //

            var intervalSpeak = null;

            function onStart() {
                if (!instance) {
                    instance = Module.init('whisper.bin');

                    if (instance) {
                        printTextarea("js: whisper initialized, instance: " + instance);
                    }
                }

                if (!instance) {
                    printTextarea("js: failed to initialize whisper");
                    return;
                }

                startRecording();

                intervalSpeak = setInterval(function() {
                    var textToSpeak = Module.get_text_to_speak();

                    if (textToSpeak != null && textToSpeak.length > 1) {
                        onSpeak(textToSpeak);
                    }
                }, 100);
            }

            function onStop() {
                stopRecording();

                if (instance) {
                    Module.free(instance);
                    instance = null;

                    printTextarea("js: talk instance freed");
                }
            }

        </script>
        <script type="text/javascript" src="talk.js"></script>
    </body>
</html>
